% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebnm.R, R/output.R
\name{ebnm}
\alias{ebnm}
\alias{output_default}
\alias{output_all}
\title{Solve the EBNM problem}
\usage{
ebnm(x, s = 1, prior_family = c("point_normal", "point_laplace",
  "point_exponential", "normal", "normal_scale_mixture", "unimodal",
  "unimodal_symmetric", "unimodal_nonnegative", "unimodal_nonpositive",
  "ash"), mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default(), optmethod = NULL,
  control = NULL, ...)

output_default()

output_all()
}
\arguments{
\item{x}{A vector of observations. Missing observations (\code{NA}s) are
allowed. If any observations are missing, the corresponding standard
errors should be set to \code{Inf}.}

\item{s}{A vector of standard errors (or a scalar if all are equal).
Standard errors may be infinite, but they may not be exactly zero.
Missing standard errors are not allowed.}

\item{prior_family}{A character string that specifies the prior family
\eqn{G}. See "Details" below.}

\item{mode}{A scalar specifying the mode of the prior \eqn{g} or
\code{"estimate"} if the mode is to be estimated from the data.}

\item{scale}{A scalar or vector specifying the scale parameter(s) of the
prior or \code{"estimate"} if the scale parameters are to be estimated
from the data. The precise interpretation of \code{scale} depends on
\code{prior_family}. For normal and point-normal families, it is a scalar
specifying the standard deviation of the normal component. For
point-Laplace and point-exponential families, it is a scalar specifying
the scale parameter of the Laplace or exponential component. For other
prior families, which are implemented using the function
\code{\link[ashr]{ash}} in package \code{ashr}, it is a vector specifying
the parameter \code{mixsd} to be passed to \code{ash} (or \code{"estimate"}
if the default \code{mixsd} is to be used).}

\item{g_init}{The prior distribution \eqn{g}. Usually this is left
unspecified (\code{NULL}) and estimated from the data. However, it can be
used in conjuction with \code{fix_g = TRUE} to fix the prior (useful, for
example, to do computations with the "true" \eqn{g} in simulations). If
\code{g_init} is specified but \code{fix_g = FALSE}, \code{g_init}
specifies the initial value of \eqn{g} used during optimization. For
\code{ash} priors, this has the side effect of fixing the \code{mode}
and \code{scale} parameters. If \code{g_init} is supplied, it should be
an object of class \code{\link[ashr]{normalmix}} for prior families
\code{normal}, \code{point_normal}, and \code{normal_scale_mixture};
class \code{\link{laplacemix}} for point-Laplace families; class
\code{\link{exponentialmix}} for point-exponential families; and class
\code{\link[ashr]{unimix}} for \code{unimodal_} families.}

\item{fix_g}{If \code{TRUE}, fix the prior \eqn{g} at \code{g_init} instead
of estimating it.}

\item{output}{A character vector indicating which values are to be returned.
Function \code{output_default()} provides the default return values, while
\code{output_all()} lists all possible return values. See "Value" below.}

\item{optmethod}{A string specifying which optimization function is to be
used. Options include \code{"nlm"}, \code{"lbfgsb"} (which calls
\code{optim} with \code{method = "L-BFGS-B"}), and \code{"trust"} (which
calls into package \code{trust}), as well as \code{"nlm_nograd"},
\code{"lbfgsb_nograd"}, and \code{"nlm_nohess"}.
Since all non-parametric families call into \code{ashr}, this parameter is
only available for parametric families (point-normal, point-Laplace,
point-exponential, and normal).}

\item{control}{A list of control parameters to be passed to the optimization
function. \code{\link[stats]{optimize}} is used for
\code{prior_family = "normal"}, while \code{\link[stats]{nlm}} is used for
parametric families unless parameter \code{optmethod} specifies otherwise.
For ash families (including \code{normal_scale_mixture} and all
\code{unimodal_} families), function \code{\link[mixsqp]{mixsqp}} in
package \code{mixsqp} is the default.}

\item{...}{Additional parameters. When \code{prior_family = "ash"} or when
a \code{unimodal_} prior is used, these parameters are passed to
function \code{\link[ashr]{ash}} in package \code{ashr}. Otherwise, they
are ignored.}
}
\value{
An \code{ebnm} object. Depending on the argument to \code{output}, the
  object is a list containing elements:
    \describe{
      \item{\code{posterior}}{A data frame of summary results (posterior
        means, standard deviations, and second moments; local false sign
        rates).}
      \item{\code{fitted_g}}{The fitted prior \eqn{\hat{g}} (an object of
        class \code{\link[ashr]{normalmix}}, \code{\link{laplacemix}}, or
        \code{\link[ashr]{unimix}}).}
      \item{\code{log_likelihood}}{The optimal log likelihood attained
        \eqn{L(\hat{g})}.}
      \item{\code{posterior_sampler}}{A function that can be used to
        produce samples from the posterior. It takes a single parameter
        \code{nsamp}, the number of posterior samples to return per
        observation.}
     }
}
\description{
Solves the empirical Bayes normal means problem using a specified family of
  priors.
}
\details{
Given vectors of data \code{x} and standard errors \code{s},
  solve the "empirical Bayes normal means" (EBNM) problem for various
  choices of prior family.
  The model is \deqn{x_j | \theta_j, s_j \sim N(\theta_j, s_j^2)}
  \deqn{\theta_j | s_j \sim g \in G} where the distribution \eqn{g} is to
  be estimated.
  The distribution \eqn{g} is referred to as the "prior distribution" for
  \eqn{\theta}
  and \eqn{G} is a specified family of prior distributions. Several options
  for \eqn{G} are implemented, some parametric and others non-parametric;
  see below for examples.

Solving the EBNM problem involves
  two steps. First, estimate \eqn{g \in  G} via maximum marginal likelihood,
  yielding an estimate \deqn{\hat{g}:= \arg\max_{g \in G} L(g)} where
  \deqn{L(g):= \prod_j \int p(x_j | \theta_j, s_j)  g(d\theta_j)}
  Second, compute the posterior distributions
  \eqn{p(\theta_j | x_j, s_j, \hat{g})} and/or summaries
  such as posterior means and posterior second moments.

The prior families that have been implemented include:
    \describe{
      \item{\code{point_normal}}{The family of mixtures where one
        component is a point mass at \eqn{\mu} and the other is a normal
        distribution centered at \eqn{\mu}.}
      \item{\code{point_laplace}}{The family of mixtures where one
        component is a point mass at zero and the other is a
        double-exponential distribution.}
      \item{\code{point_exponential}}{The family of mixtures where one
        component is a point mass at zero and the other is a
        (nonnegative) exponential distribution.}
      \item{\code{normal}}{The family of normal distributions.}
      \item{\code{normal_scale_mixture}}{The family of scale mixtures of
        normals.}
      \item{\code{unimodal}}{The family of all unimodal distributions.}
      \item{\code{unimodal_symmetric}}{The family of symmetric unimodal
        distributions.}
      \item{\code{unimodal_nonnegative}}{The family of unimodal
        distributions with support constrained to be greater than the mode.}
      \item{\code{unimodal_nonpositive}}{The family of unimodal
        distributions with support constrained to be less than the mode.}
    }
}
\section{Functions}{
\itemize{
\item \code{output_default}: Defines the default return values.

\item \code{output_all}: Lists all valid return values.
}}

\examples{
theta <- c(rep(0, 100), rexp(100))
s <- 1
x <- theta + rnorm(200, 0, s)

# The following are equivalent:
pn.res <- ebnm(x, s, prior_family = "point_normal")
pn.res <- ebnm_point_normal(x, s)

# Inspect results:
pn.res$log_likelihood
plot(x, pn.res$posterior$mean)

# Fix the scale parameter:
pl.res <- ebnm_point_laplace(x, s, scale = 1)
pl.res$fitted_g$scale

# Estimate the mode:
normal.res <- ebnm_normal(x, s, mode = "estimate")
normal.res$fitted_g$mean

# Use an initial g (this fixes mode and scale for ash priors):
normalmix.res <- ebnm_normal_scale_mixture(x, s, g_init = pn.res$fitted_g)

# Fix g and get more output:
g_init <- pn.res$fitted_g
pn.res <- ebnm_point_normal(x, s, g_init = g_init, fix_g = TRUE,
                            output = "posterior_sampler")
pn.res <- ebnm_point_normal(x, s, g_init = g_init, fix_g = TRUE,
                            output = output_all())

# Examples of usage of control parameter:
#  point_normal uses nlm:
pn.res <- ebnm_point_normal(x, s, control = list(print.level = 1))
#  unimodal uses mixsqp:
unimodal.res <- ebnm_unimodal(x, s, control = list(verbose = TRUE))

}
\seealso{
Calling functions \code{\link{ebnm_point_normal}},
  \code{\link{ebnm_point_laplace}},
  \code{\link{ebnm_point_exponential}}, \code{\link{ebnm_normal}},
  \code{\link{ebnm_normal_scale_mixture}}, \code{\link{ebnm_unimodal}},
  \code{\link{ebnm_unimodal_symmetric}},
  \code{\link{ebnm_unimodal_nonnegative}},
  \code{\link{ebnm_unimodal_nonpositive}}, and \code{\link{ebnm_ash}}
  is equivalent to calling \code{ebnm} with \code{prior_family} set
  accordingly.
}
